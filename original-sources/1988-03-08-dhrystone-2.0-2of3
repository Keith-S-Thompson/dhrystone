Path: utzoo!mnetor!uunet!pcrat!dry
From: d...@pcrat.UUCP (Dhrystone)
Newsgroups: comp.arch
Subject: Dhrystone 2.0 (2 of 3)
Message-ID: <493@pcrat.UUCP>
Date: 9 Mar 88 03:16:24 GMT
Organization: PC Research, Inc., Tinton Falls, NJ
Lines: 1416
Keywords: benchmark


#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	README
#	dhry_global.h
#	dhry_pack_1.c
#	dhry_pack_2.c
# This archive created: Tue Mar  8 22:04:55 1988
export PATH; PATH=/bin:/usr/bin:$PATH
if test -f 'README'
then
	echo shar: "will not over-write existing file 'README'"
else
sed 's/^X//' << \SHAR_EOF > 'README'
X
X
X    Dhrystone Benchmark: Rationale for Version 2 and Measurement Rules
X
X
X                 Reinhold P. Weicker
X                 Siemens AG, E STE 35
X                 Postfach 3240
X                 D-8520 Erlangen
X                 Germany (West)
X
X
X
X
X1.  Why a Version 2 of Dhrystone?
X
XThe Dhrystone benchmark program [1] has become a popular benchmark  for
XCPU/compiler  performance  measurement,  in  particular  in the area of
Xminicomputers, workstations, PC's and  microprocesors.   It  apparently
Xsatisfies a need for an easy-to-use integer benchmark; it gives a first
Xperformance indication which  is  more  meaningful  than  MIPS  numbers
Xwhich,  in  their  literal  meaning  (million instructions per second),
Xcannot be used across different instruction sets (e.g. RISC vs.  CISC).
XWith  the  increasing  use  of  the  benchmark,  it  seems necessary to
Xreconsider the benchmark and to check whether it can still fulfill this
Xfunction.   Version  2  of  Dhrystone  is  the  result  of  such  a re-
Xevaluation, it has been made for two reasons:
X
Xo Dhrystone has been published in Ada [1], and Versions in Ada,  Pascal
X  and  C  have  been  distributed  by Reinhold Weicker via floppy disk.
X  However, the version that was used most often  for  benchmarking  has
X  been  the version made by Rick Richardson by another translation from
X  the Ada version into the C programming language, this  has  been  the
X  version distributed via the UNIX network Usenet [2].
X
X  There is an obvious need for a common C version of Dhrystone, since C
X  is  at  present  the most popular system programming language for the
X  class of systems (microcomputers, minicomputers, workstations)  where
X  Dhrystone  is  used  most.  There should be, as far as possible, only
X  one C version of Dhrystone such that results can be compared  without
X  restrictions.  In  the  past,  the  C  versions  distributed  by Rick
X  Richardson (Version 1.1) and by Reinhold Weicker  had  small  (though
X  not significant) differences.
X
X  Together with the new C version, the Ada  and  Pascal  versions  have
X  been updated as well.
X
Xo As far as it is possible without changes to the Dhrystone statistics,
X  optimizing  compilers  should  be prevented from removing significant
X  statements.  It has turned out in the past that optimizing  compilers
X  suppressed  code  generation  for  too many statements (by "dead code
X  removal" or "dead variable  elimination").   This  has  lead  to  the
X  danger  that  benchmarking results obtained by a naive application of
X  Dhrystone - without inspection of the code that was generated - could
X  become meaningless.
X
XThe overall policiy for version 2 has been  that  the  distribution  of
Xstatements,  operand types and operand locality described in [1] should
Xremain  unchanged  as  much  as  possible.   (Very  few  changes   were
Xnecessary;  their  impact  should  be  negligible.)  Also, the order of
Xstatements should  remain  unchanged.  Although  I  am  aware  of  some
Xcritical  remarks on the benchmark - I agree with several of them - and
Xknow some suggestions for improvement, I  didn't  want  to  change  the
Xbenchmark  into  something  different  from  what  has  become known as
X"Dhrystone"; the confusion generated by such a  change  would  probably
Xoutweight  the  benefits. If I were to write a new benchmark program, I
Xwouldn't give it the name "Dhrystone" since this  denotes  the  program
Xpublished in [1].  However, I do recognize the need for a larger number
Xof representative programs that can be used as benchmarks; users should
Xalways be encouraged to use more than just one benchmark.
X
XThe  new  versions  (version  2.0  for  C,  Pascal  and  Ada)  will  be
Xdistributed  as  widely  as  possible.   Readers  who  want  to use the
Xbenchmark for their own measurements can  obtain  a  copy  in  machine-
Xreadable  form on floppy disk (MS-DOS or XENIX format) from the author.
XIn addition, the new versions have been  posted  to  the  UNIX  network
XUsenet.
X
X
X2.  Overall Characteristics of Version 2
X
XIn general, version 2 follows - in the parts that are  significant  for
Xperformance  measurement,  i.e.   within  the  measurement  loop  - the
Xpublished (Ada) version and  the  C  versions  previously  distributed.
XWhere  the  versions  distributed  by  Rick Richardson [2] and Reinhold
XWeicker have been different, it  follows  the  version  distributed  by
XReinhold  Weicker.  (However,  the  differences have been so small that
Xtheir impact on execution time in all likelihood has been  negligible.)
XThe  initialization  and  UNIX  instrumentation  part  - which had been
Xomitted in [1] - follows mostly  the  ideas  of  Rick  Richardson  [2].
XHowever,  any changes in the initialization part and in the printing of
Xthe result have no impact on performance  measurement  since  they  are
Xoutside  the  measaurement  loop.   As a concession to older compilers,
Xnames have been made unique within the first 8  characters  for  the  C
Xversion.
X
XThe original publication of Dhrystone did not  contain  any  statements
Xfor  time  measurement  since  they  are  necessarily system-dependent.
XHowever, it turned out that it is not enough just to inclose  the  main
Xprocedure of Dhrystone in a loop and to measure the execution time.  If
Xthe variables that are computed are not  used  somehow,  there  is  the
Xdanger  that  the  compiler  considers  them  as  "dead  variables" and
Xsuppresses code generation for a part of the statements.  Therefore  in
Xversion  2  all  variables  of  "main"  are  printed  at the end of the
Xprogram. This  also  permits  some  plausibility  control  for  correct
Xexecution of the benchmark.
X
XAt several places in the benchmark, code has been added,  but  only  in
Xbranches  that  are  not  executed.  The  intention  is that optimizing
Xcompilers should be prevented from moving code out of  the  measurement
Xloop,  or  from  removing code altogether. Statements that are executed
Xhave been changed in very few places only.  In these  cases,  only  the
Xrole  of  some operands has been changed, and it was made sure that the
Xnumbers  defining  the  "Dhrystone   distribution"   (distribution   of
Xstatements, operand types and locality) still hold as much as possible.
XExcept for sophisticated  optimizing  compilers,  execution  times  for
Xversion 2.0 should be the same as for previous versions.
X
XBecause of the self-imposed limitation that the order and  distribution
Xof the executed statements should not be changed, there are still cases
Xwhere optimizing compilers may not generate code for  some  statements.
XTo   a   certain  degree,  this  is  unavoidable  for  small  synthetic
Xbenchmarks.  Users of the benchmark are advised to check code  listings
Xwhether code is generated for all statements of Dhrystone.
X
XContrary to the suggestion in the published paper and  its  realization
Xin  the  versions  previously  distributed, no attempt has been made to
Xsubtract the time for the measurement loop overhead. (This  calculation
Xhas  proven  difficult  to implement in a correct way, and its omission
Xmakes the program simpler.) However, since the loop check is  now  part
Xof  the benchmark, this does have an impact - though a very minor one -
Xon the  distribution  statistics  which  have  been  updated  for  this
Xversion.
X
X
X3.  Discussion of Individual Changes
X
XIn this section, all changes are described that affect the  measurement
Xloop and that are not just renamings of variables. All remarks refer to
Xthe C version; the other language versions have been updated similarly.
X
XIn addition to adding the measurement loop and the printout statements,
Xchanges have been made at the following places:
X
Xo In procedure "main", three statements have been  added  in  the  non-
X  executed "then" part of the statement
X
X        if (Enum_Loc == Func_1 (Ch_Index, 'C'))
X
X  they are
X
X        strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
X        Int_2_Loc = Run_Index;
X        Int_Glob = Run_Index;
X
X  The string assignment prevents movement of the  preceding  assignment
X  to  Str_2_Loc  (5'th statement of "main") out of the measurement loop
X  (This probably will not happen for the C version, but it  did  happen
X  with  another  language  and  compiler.)  The assignment to Int_2_Loc
X  prevents value propagation  for  Int_2_Loc,  and  the  assignment  to
X  Int_Glob  makes  the  value  of  Int_Glob possibly dependent from the
X  value of Run_Index.
X
Xo In the three arithmetic computations at the end  of  the  measurement
X  loop  in  "main  ", the role of some variables has been exchanged, to
X  prevent the division from just cancelling out the  multiplication  as
X  it  was in [1].  A very smart compiler might have recognized this and
X  suppressed code generation for the division.
X
Xo For Proc_2, no code has been changed, but the values  of  the  actual
X  parameter have changed due to changes in "main".
X
Xo In Proc_4, the second assignment has been changed from
X
X        Bool_Loc = Bool_Loc | Bool_Glob;
X
X  to
X
X        Bool_Glob = Bool_Loc | Bool_Glob;
X
X  It now assigns a value to  a  global  variable  instead  of  a  local
X  variable (Bool_Loc); Bool_Loc would be a "dead variable" which is not
X  used afterwards.
X
Xo In Func_1, the statement
X
X        Ch_1_Glob = Ch_1_Loc;
X
X  was added in the non-executed "else" part of the "if"  statement,  to
X  prevent  the  suppression  of  code  generation for the assignment to
X  Ch_1_Loc.
X
Xo In Func_2, the second character comparison statement has been changed
X  to
X
X        if (Ch_Loc == 'R')
X
X  ('R' instead of 'X') because a comparison with 'X' is implied in  the
X  preceding "if" statement.
X
X  Also in Func_2, the statement
X
X        Int_Glob = Int_Loc;
X
X  has been added in the non-executed part of the last  "if"  statement,
X  in order to prevent Int_Loc from becoming a dead variable.
X
XThe distribution statistics have been changed only by the  addition  of
Xthe  measurement  loop  iteration (1 additional statement, 4 additional
Xlocal integer operands) and  by  the  change  in  Proc_4  (one  operand
Xchanged  from  local  to  global).  The  distribution statistics in the
Xcomment headers have been updated accordingly.
X
X
X4.  String Operations
X
XThe string operations (string assignment and  string  comparison)  have
Xnot  been  changed,  to  keep  the program consistent with the original
Xversion.
X
XThere has been some  concern  that  the  string  operations  are  over-
Xrepresented  in  the  program,  and that execution time is dominated by
Xthese  operations.   This  was  true  in  particular  when   optimizing
Xcompilers  removed  too much code in the main part of the program, this
Xshould have been mitigated in version 2.
X
XIt should be noted that this is a language-dependent issue:   Dhrystone
Xwas  first published in Ada, and with Ada or Pascal semantics, the time
Xspent in the string operations is,  at  least  in  all  implementations
Xknown  to  me, considerably smaller.  In Ada and Pascal, assignment and
Xcomparison of strings are operators defined in the  language,  and  the
Xupper  bounds of the strings occuring in Dhrystone are part of the type
Xinformation known at compilation time.   The  compilers  can  therefore
Xgenerate efficient inline code.  In C, string assignemt and comparisons
Xare not part of the language, so the C library functions  "strcpy"  and
X"strcmp"  have  to  be used.  In addition to the overhead caused by two
Xadditional function  calls,  these  functions  are  defined  for  null-
Xterminated  strings  where  the  length  of the strings is not known at
Xcompilation time;  the  function  has  to  check  every  byte  for  the
Xtermination condition (the null byte).
X
XObviously, a C library which includes efficiently  coded  "strcpy"  and
X"strcmp"  functions  helps to obtain good Dhrystone results. However, I
Xdon't think that this is unfair since string functions do  occur  quite
Xfrequently  in real programs (editors, command interpreters, etc.).  If
Xthe strings functions are  implemented  efficiently,  this  helps  real
Xprograms as well as benchmark programs.
X
XI admit that the string comparison in Dhrystone terminates later (after
Xscanning  20 characters) than most string comparisons in real programs.
XFor consistency with  the  original  benchmark,  I  didn't  change  the
Xprogram despite this weakness.
X
X
X5.  Intended Use of Dhrystone
X
XWhen Dhrystone is used, the following "ground rules" apply:
X
Xo Separate compilation (Ada and C versions)
X
X  As  mentioned  in  [1],  Dhrystone  was  written  to  reflect  actual
X  programming  practice  in  systems  programming.   The  division into
X  several compilation units (5 in the Ada version, 3 in the C  version)
X  is  intended, as is the distribution of inter-module and intra-module
X  subprogram  calls.   Although  on  many  systems  there  will  be  no
X  difference  in  execution  time  to  a  Dhrystone  version  where all
X  compilation units are merged into one file, the rule is that separate
X  compilation  should  be used.  The intention is that real programming
X  practice, where programs consist of  several  independently  compiled
X  units, should be reflected.  This also has implies that the compiler,
X  while compiling one  unit,  has  no  information  about  the  use  of
X  variables,  register  allocation  etc.  occuring in other compilation
X  units.  Although in real life  compilation  units  will  probably  be
X  larger,  the  intention is that these effects of separate compilation
X  are modeled in Dhrystone.
X
X  A few  language  systems  have  post-linkage  optimization  available
X  (e.g.,  final  register allocation is performed after linkage).  This
X  is a borderline case: Post-linkage optimization  involves  additional
X  program  preparation time (although not as much as compilation in one
X  unit) which may prevent its general use in practical programming.   I
X  think that since it defeats the intentions given above, it should not
X  be used for Dhrystone.
X
X  Unfortunately, ISO/ANSI Pascal does not contain language features for
X  separate  compilation.   Although  most  commercial  Pascal compilers
X  provide separate compilation in  some  way,  we  cannot  use  it  for
X  Dhrystone  since such a version would not be portable.  Therefore, no
X  attempt has been made  to  provide  a  Pascal  version  with  several
X  compilation units.
X
Xo No procedure merging
X
X  Although  Dhrystone  contains  some  very  short   procedures   where
X  execution  would  benefit  from  procedure  merging  (inlining, macro
X  expansion of procedures), procedure merging is not to be  used.   The
X  reason is that the percentage of procedure and function calls is part
X  of the "Dhrystone distribution" of statements contained in [1].
X
Xo Other optimizations are allowed, but they should be indicated
X
X  It is  often  hard  to  draw  an  exact  line  between  "normal  code
X  generation"  and  "optimization" in compilers: Some compilers perform
X  operations by default that are invoked in other compilers  only  when
X  optimization  is explicitly requested.  Also, we cannot avoid that in
X  benchmarking people try to achieve  results  that  look  as  good  as
X  possible.   Therefore,  optimizations  performed by compilers - other
X  than those listed above - are not forbidden when Dhrystone  execution
X  times  are measured.  Dhrystone is not intended to be non-optimizable
X  but is intended to be similarly optimizable as normal programs.   For
X  example,  there  are  several  places  in Dhrystone where performance
X  benefits from optimizations like  Common  Subexpression  Elimination,
X  Value Propagation etc., but normal programs usually also benefit from
X  these optimizations.  Therefore, no effort was made  to  artificially
X  prevent  such  optimizations.   However,  measurement  reports should
X  indicate which compiler  optimization  levels  have  been  used,  and
X  reporting  results with different levels of compiler optimization for
X  the same hardware is encouraged.
X
Xo Default results are those without "register" declarations (C version)
X
X  When Dhrystone results are quoted without  additional  qualification,
X  they  should  be  understood  as  results obtained without use of the
X  "register" attribute. Good compilers should be able to make good  use
X  of  registers  even  without  explicit register declarations ([3], p.
X  193).
X
XOf  course,  for  experimental  purposes,  post-linkage   optimization,
Xprocedure  merging  and/or  compilation  in  one  unit  can  be done to
Xdetermine their effects.  However,  Dhrystone  numbers  obtained  under
Xthese   conditions  should  be  explicitly  marked  as  such;  "normal"
XDhrystone results should be understood as  results  obtained  following
Xthe ground rules listed above.
X
XIn any case, for serious performance evaluation, users are  advised  to
Xask  for  code listings and to check them carefully.  In this way, when
Xresults for different systems  are  compared,  the  reader  can  get  a
Xfeeling how much performance difference is due to compiler optimization
Xand how much is due to hardware speed.
X
X
X6.  Acknowledgements
X
XThe C version 2.0 of Dhrystone has been developed in  cooperation  with
XRick Richardson (Tinton Falls, NJ), it incorporates many ideas from the
X"Version 1.1" distributed previously  by  him  over  the  UNIX  network
XUsenet.  Through  his  activity with Usenet, Rick Richardson has made a
Xvery valuable contribution to the dissemination of  the  benchmark.   I
Xalso  thank  Chaim  Benedelac  (National  Semiconductor),  David Ditzel
X(SUN), Earl Killian and John  Mashey  (MIPS),  Alan  Smith  and  Rafael
XSaavedra-Barrera  (UC  at  Berkeley)  for  their  help with comments on
Xearlier versions of the benchmark.
X
X
X7.  Bibliography
X
X[1]
X   Reinhold P. Weicker:  Dhrystone:  A  Synthetic  Systems  Programming
X   Benchmark.
X   Communications of the ACM 27, 10 (Oct. 1984), 1013-1030
X
X[2]
X   Rick Richardson: Dhrystone 1.1 Benchmark Summary (and Program Text)
X   Informal Distribution via "Usenet", Last Version Known to me:  Sept.
X   21, 1987
X
X[3]
X   Brian W.  Kernighan  and  Dennis  M.  Ritchie:   The  C  Programming
X   Language.
X   Prentice-Hall, Englewood Cliffs (NJ) 1978
X
SHAR_EOF
fi
if test -f 'dhry_global.h'
then
	echo shar: "will not over-write existing file 'dhry_global.h'"
else
sed 's/^X//' << \SHAR_EOF > 'dhry_global.h'
X/*
X ****************************************************************************
X *
X *                   "DHRYSTONE" Benchmark Program
X *                   -----------------------------
X *                                                                            
X *  Version:    C, Version 2.0
X *                                                                            
X *  File:       dhry_global.h (part 1 of 3)
X *
X *  Date:       March 3, 1988
X *
X *  Author:     Reinhold P. Weicker
X *                      Siemens AG, E STE 35
X *                      Postfach 3240
X *                      8520 Erlangen
X *                      Germany (West)
X *                              Phone:  [xxx-49]-9131-7-20330
X *                                      (8-17 Central European Time)
X *                              Usenet: ..!mcvax!unido!estevax!weicker
X *
X *              Original Version (in Ada) published in
X *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
X *              pp. 1013 - 1030, together with the statistics
X *              on which the distribution of statements etc. is based.
X *
X *              In this C version, the following C library functions are used:
X *              - strcpy, strcmp (inside the measurement loop)
X *              - printf, scanf (outside the measurement loop)
X *              In addition, UNIX system calls "times ()" or "time ()"
X *              are used for execution time measurement. For measurements
X *              on other systems, these calls have to be changed.
X *
X *  Collection of Results:
X *              Reinhold Weicker (address see above) and
X *              
X *              Rick Richardson
X *              PC Research. Inc.
X *              94 Apple Orchard Drive
X *              Tinton Falls, NJ 07724
X *                      Phone:  (201) 834-1378 (9-17 EST)               
X *                      Usenet: ...!seismo!uunet!pcrat!rick
X *
X *      Please send results to Reinhold Weicker and/or Rick Richardson.
X *      Complete information should be given on hardware and software used.
X *      Hardware information includes: Machine type, CPU, type and size
X *      of caches; for microprocessors: clock frequency, memory speed
X *      (number of wait states).
X *      Software information includes: Compiler (and runtime library)
X *      manufacturer and version, compilation switches, OS version.
X *      The Operating System version may give an indication about the
X *      compiler; Dhrystone itself performs no OS calls in the measurement loop.
X *
X *      The complete output generated by the program should be mailed
X *      such that at least some checks for correctness can be made.
X *
X ***************************************************************************
X *
X *  History:    This version C/2.0 has been made for two reasons:
X *
X *              1) There is an obvious need for a common C version of
X *              Dhrystone, since C is at present the most popular system
X *              programming language for the class of processors
X *              (microcomputers, minicomputers) where Dhrystone is used most.
X *              There should be, as far as possible, only one C version of
X *              Dhrystone such that results can be compared without
X *              restrictions. In the past, the C versions distributed
X *              by Rick Richardson (Version 1.1) and by Reinhold Weicker
X *              had small (though not significant) differences.
X *
X *              2) As far as it is possible without changes to the Dhrystone
X *              statistics, optimizing compilers should be prevented from
X *              removing significant statements.
X *
X *              This C version has been developed in cooperation with
X *              Rick Richardson (Tinton Falls, NJ), it incorporates many
X *              ideas from the "Version 1.1" distributed previously by
X *              him over the UNIX network Usenet.
X *              I also thank Chaim Benedelac (National Semiconductor),
X *              David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
X *              Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
X *              for their help with comments on earlier versions of the
X *              benchmark.
X *
X *  Changes:    In the initialization part, this version follows mostly
X *              Rick Richardson's version distributed via Usenet, not the
X *              version distributed earlier via floppy disk by Reinhold Weicker.
X *              As a concession to older compilers, names have been made
X *              unique within the first 8 characters.
X *              Inside the measurement loop, this version follows the
X *              version previously distributed by Reinhold Weicker.
X *
X *              At several places in the benchmark, code has been added,
X *              but within the measurement loop only in branches that 
X *              are not executed. The intention is that optimizing compilers
X *              should be prevented from moving code out of the measurement
X *              loop, or from removing code altogether. Since the statements
X *              that are executed within the measurement loop have NOT been
X *              changed, the numbers defining the "Dhrystone distribution"
X *              (distribution of statements, operand types and locality)
X *              still hold. Except for sophisticated optimizing compilers,
X *              execution times for this version should be the same as
X *              for previous versions.
X *              
X *              Since it has proven difficult to subtract the time for the
X *              measurement loop overhead in a correct way, the loop check
X *              has been made a part of the benchmark. This does have
X *              an impact - though a very minor one - on the distribution
X *              statistics which have been updated for this version.
X *
X *              All changes within the measurement loop are described
X *              and discussed in the companion paper "Rationale for
X *              Dhrystone version 2".
X *
X *              Because of the self-imposed limitation that the order and
X *              distribution of the executed statements should not be
X *              changed, there are still cases where optimizing compilers
X *              may not generate code for some statements. To a certain
X *              degree, this is unavoidable for small synthetic benchmarks.
X *              Users of the benchmark are advised to check code listings
X *              whether code is generated for all statements of Dhrystone.
X *
X ***************************************************************************
X *
X * Defines:     The following "Defines" are possible:
X *              -DREG=register          (default: Not defined)
X *                      As an approximation to what an average C programmer
X *                      might do, the "register" storage class is applied
X *                      (if enabled by -DREG=register)
X *                      - for local variables, if they are used (dynamically)
X *                        five or more times
X *                      - for parameters if they are used (dynamically)
X *                        six or more times
X *                      Note that an optimal "register" strategy is
X *                      compiler-dependent, and that "register" declarations
X *                      do not necessarily lead to faster execution.
X *              -DNOSTRUCTASSIGN        (default: Not defined)
X *                      Define if the C compiler does not support
X *                      assignment of structures.
X *              -DNOENUMS               (default: Not defined)
X *                      Define if the C compiler does not support
X *                      enumeration types.
X *              -DTIMES                 (default)
X *              -DTIME
X *                      The "times" function of UNIX (returning process times)
X *                      or the "time" function (returning wallclock time)
X *                      is used for measurement. 
X *                      For single user machines, "time ()" is adequate. For
X *                      multi-user machines where you cannot get single-user
X *                      access, use the "times ()" function. If you have
X *                      neither, use a stopwatch in the dead of night.
X *                      "printf"s are provided marking the points "Start Timer"
X *                      and "Stop Timer". DO NOT use the UNIX "time(1)"
X *                      command, as this will measure the total time to
X *                      run this program, which will (erroneously) include
X *                      the time to allocate storage (malloc) and to perform
X *                      the initialization.
X *              -DHZ=nnn                (default: 60)
X *                      The function "times" returns process times in
X *                      1/HZ seconds, with HZ = 60 for most systems.
X *                      CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
X *                      THE DEFAULT VALUE.
X *
X ***************************************************************************
X *
X *  Compilation model and measurement (IMPORTANT):
X *
X *  This C version of Dhrystone consists of three files:
X *  - dhry_global.h (this file, containing global definitions and comments)
X *  - dhry_pack_1.c (containing the code corresponding to Ada package Pack_1)
X *  - dhry_pack_2.c (containing the code corresponding to Ada package Pack_2)
X *
X *  The following "ground rules" apply for measurements:
X *  - Separate compilation
X *  - No procedure merging
X *  - Otherwise, compiler optimizations are allowed but should be indicated
X *  - Default results are those without register declarations
X *  See the companion paper "Rationale for Dhrystone Version 2" for a more
X *  detailed discussion of these ground rules.
X *
X *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
X *  models ("small", "medium", "large" etc.) should be given if possible,
X *  together with a definition of these models for the compiler system used.
X *
X **************************************************************************
X *
X *  Dhrystone (C version) statistics:
X *
X *  [Comment from the first distribution, updated for version 2.
X *   Note that because of language differences, the numbers are slightly
X *   different from the Ada version.]
X *
X *  The following program contains statements of a high level programming
X *  language (here: C) in a distribution considered representative:           
X *
X *    assignments                  52 (51.0 %)
X *    control statements           33 (32.4 %)
X *    procedure, function calls    17 (16.7 %)
X *
X *  103 statements are dynamically executed. The program is balanced with
X *  respect to the three aspects:                                             
X *
X *    - statement type
X *    - operand type
X *    - operand locality
X *         operand global, local, parameter, or constant.                     
X *
X *  The combination of these three aspects is balanced only approximately.    
X *
X *  1. Statement Type:                                                        
X *  -----------------             number
X *
X *     V1 = V2                     9
X *       (incl. V1 = F(..)
X *     V = Constant               12
X *     Assignment,                 7
X *       with array element
X *     Assignment,                 6
X *       with record component
X *                                --
X *                                34       34
X *
X *     X = Y +|-|"&&"|"|" Z        5
X *     X = Y +|-|"==" Constant     6
X *     X = X +|- 1                 3
X *     X = Y *|/ Z                 2
X *     X = Expression,             1
X *           two operators
X *     X = Expression,             1
X *           three operators
X *                                --
X *                                18       18
X *
X *     if ....                    14
X *       with "else"      7
X *       without "else"   7
X *           executed        3
X *           not executed    4
X *     for ...                     7  |  counted every time
X *     while ...                   4  |  the loop condition
X *     do ... while                1  |  is evaluated
X *     switch ...                  1
X *     break                       1
X *     declaration with            1
X *       initialization
X *                                --
X *                                34       34
X *
X *     P (...)  procedure call    11
X *       user procedure      10
X *       library procedure    1
X *     X = F (...)
X *             function  call      6
X *       user function        5                                         
X *       library function     1                                               
X *                                --                                          
X *                                17       17
X *                                        ---
X *                                        103
X *
X *    The average number of parameters in procedure or function calls
X *    is 1.82 (not counting the function values as implicit parameters).
X *
X *
X *  2. Operators
X *  ------------
X *                          number    approximate
X *                                    percentage
X *
X *    Arithmetic             32          50.8                                 
X *
X *       +                     21          33.3                              
X *       -                      7          11.1                              
X *       *                      3           4.8
X *       / (int div)            1           1.6
X *
X *    Comparison             27           42.8
X *
X *       ==                     9           14.3
X *       /=                     4            6.3
X *       >                      1            1.6
X *       <                      3            4.8
X *       >=                     1            1.6
X *       <=                     9           14.3
X *
X *    Logic                   4            6.3
X *
X *       && (AND-THEN)          1            1.6
X *       |  (OR)                1            1.6
X *       !  (NOT)               2            3.2
X * 
X *                           --          -----
X *                           63          100.1
X *
X *
X *  3. Operand Type (counted once per operand reference):
X *  ---------------
X *                          number    approximate
X *                                    percentage
X *
X *     Integer               175        72.3 %
X *     Character              45        18.6 %
X *     Pointer                12         5.0 %
X *     String30                6         2.5 %
X *     Array                   2         0.8 %
X *     Record                  2         0.8 %
X *                           ---       -------
X *                           242       100.0 %
X *
X *  When there is an access path leading to the final operand (e.g. a record
X *  component), only the final data type on the access path is counted.       
X *
X *
X *  4. Operand Locality:                                                      
X *  -------------------
X *                                number    approximate
X *                                          percentage
X *
X *     local variable              114        47.1 %
X *     global variable              22         9.1 %
X *     parameter                    45        18.6 %
X *        value                        23         9.5 %
X *        reference                    22         9.1 %
X *     function result               6         2.5 %
X *     constant                     55        22.7 %
X *                                 ---       -------
X *                                 242       100.0 %
X *
X *
X *  The program does not compute anything meaningful, but it is syntactically
X *  and semantically correct. All variables have a value assigned to them
X *  before they are used as a source operand.
X *
X *  There has been no explicit effort to account for the effects of a
X *  cache, or to balance the use of long or short displacements for code or
X *  data.
X *
X ***************************************************************************
X */
X
X/* Compiler and system dependent definitions: */
X
X#ifndef TIME
X#ifndef TIMES
X#define TIMES
X#endif
X#endif
X                /* Use "times" function for measurement */
X                /* unless explicitly defined otherwise  */
X#ifndef HZ
X#define HZ      60
X#endif
X                /* Use HZ = 60 for "times" function     */
X                /* unless explicitly defined otherwise  */
X
X#ifdef TIMES
X#include <sys/types.h>
X#include <sys/times.h>
X                /* for "times" */
X#endif
X
X#define Mic_secs_Per_Second     1000000.0
X                /* UNIX C returns process times in seconds/HZ */
X
X#ifdef  NOSTRUCTASSIGN
X#define structassign(d, s)      memcpy(&(d), &(s), sizeof(d))
X#else
X#define structassign(d, s)      d = s
X#endif
X
X#ifdef  NOENUM
X#define Ident_1 0
X#define Ident_2 1
X#define Ident_3 2
X#define Ident_4 3
X#define Ident_5 4
X  typedef int   Enumeration;
X#else
X  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
X                Enumeration;
X#endif
X        /* for boolean and enumeration types in Ada, Pascal */
X
X/* General definitions: */
X
X#include <stdio.h>
X                /* for strcpy, strcmp */
X
X#define Null 0 
X                /* Value of a Null pointer */
X#define true  1
X#define false 0
X
Xtypedef int     One_Thirty;
Xtypedef int     One_Fifty;
Xtypedef char    Capital_Letter;
Xtypedef int     Boolean;
Xtypedef char    Str_30 [31];
Xtypedef int     Arr_1_Dim [50];
Xtypedef int     Arr_2_Dim [50] [50];
X
Xtypedef struct record 
X    {
X    struct record *Ptr_Comp;
X    Enumeration    Discr;
X    union {
X          struct {
X                  Enumeration Enum_Comp;
X                  int         Int_Comp;
X                  char        Str_Comp [31];
X                  } var_1;
X          struct {
X                  Enumeration E_Comp_2;
X                  char        Str_2_Comp [31];
X                  } var_2;
X          struct {
X                  char        Ch_1_Comp;
X                  char        Ch_2_Comp;
X                  } var_3;
X          } variant;
X      } Rec_Type, *Rec_Pointer;
X
X
SHAR_EOF
fi
if test -f 'dhry_pack_1.c'
then
	echo shar: "will not over-write existing file 'dhry_pack_1.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dhry_pack_1.c'
X/*
X ****************************************************************************
X *
X *                   "DHRYSTONE" Benchmark Program
X *                   -----------------------------
X *                                                                            
X *  Version:    C, Version 2.0
X *                                                                            
X *  File:       dhry_pack_1.c (part 2 of 3)
X *
X *  Date:       March 3, 1988
X *
X *  Author:     Reinhold P. Weicker
X *
X ****************************************************************************
X */
X
X#include "dhry_global.h"
X
X/* Global Variables: */
X
XRec_Pointer     Ptr_Glob,
X                Next_Ptr_Glob;
Xint             Int_Glob;
XBoolean         Bool_Glob;
Xchar            Ch_1_Glob,
X                Ch_2_Glob;
Xint             Arr_1_Glob [50];
Xint             Arr_2_Glob [50] [50];
X
Xextern char     *malloc ();
XEnumeration     Func_1 ();
X  /* forward declaration necessary since Enumeration may not simply be int */
X
X#ifndef REG
X        Boolean Reg = false;
X#define REG
X        /* REG becomes defined as empty */
X        /* i.e. no register variables   */
X#else
X        Boolean Reg = true;
X#endif
X
X/* variables for time measurement: */
X
X#ifdef TIMES
Xstruct tms      time_info;
Xextern  int     times ();
X                /* see library function "times" */
X#endif
X#ifdef TIME
Xextern long     time();
X                /* see library function "time"  */
X#endif
X
X#define Too_Small_Time 2
X                /* Measurements should last at least 2 seconds */
X
Xlong            Begin_Time,
X                End_Time,
X                User_Time;
Xfloat           Microseconds,
X                Dhrystones_Per_Second;
X
X/* end of variables for time measurement */
X
X
Xmain ()
X/*****/
X
X  /* main program, corresponds to procedures        */
X  /* Main and Proc_0 in the Ada version             */
X
X{
X        One_Fifty       Int_1_Loc;
X  REG   One_Fifty       Int_2_Loc;
X        One_Fifty       Int_3_Loc;
X  REG   char            Ch_Index;
X        Enumeration     Enum_Loc;
X        Str_30          Str_1_Loc;
X        Str_30          Str_2_Loc;
X  REG   int             Run_Index;
X  REG   int             Number_Of_Runs;
X
X
X  /* Initializations */
X
X  Next_Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
X  Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
X
X  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
X  Ptr_Glob->Discr                       = Ident_1;
X  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
X  Ptr_Glob->variant.var_1.Int_Comp      = 40;
X  strcpy (Ptr_Glob->variant.var_1.Str_Comp, 
X          "DHRYSTONE PROGRAM, SOME STRING");
X  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
X
X  Arr_2_Glob [8][7] = 10;
X        /* Was missing in published program. Without this               */
X        /* initialization, Arr_2_Glob [8][7] would have an              */
X        /* undefined value.                                             */
X        /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
X        /* overflow may occur for this array element.                   */
X
X  printf ("\n");
X  printf ("Dhrystone Benchmark, Version 2.0 (Language: C)\n");
X  printf ("\n");
X  if (Reg)
X  {
X    printf ("Program compiled with 'register' attribute\n");
X    printf ("\n");
X  }
X  else
X  {
X    printf ("Program compiled without 'register' attribute\n");
X    printf ("\n");
X  }
X  printf ("Please give the number of runs through the benchmark: ");
X  {
X    int n;
X    scanf ("%d", &n);
X    Number_Of_Runs = n;
X  }
X  printf ("\n");
X
X  printf ("Execution starts, %d runs through Dhrystone\n", Number_Of_Runs);
X
X  /***************/
X  /* Start timer */
X  /***************/
X 
X#ifdef TIMES
X  times (&time_info);
X  Begin_Time = (long) time_info.tms_utime;
X#endif
X#ifdef TIME
X  Begin_Time = time ( (long *) 0);
X#endif
X
X  for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
X  {
X
X    Proc_5();
X    Proc_4();
X      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
X    Int_1_Loc = 2;
X    Int_2_Loc = 3;
X    strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
X    Enum_Loc = Ident_2;
X    Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
X      /* Bool_Glob == 1 */
X    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
X    {
X      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
X        /* Int_3_Loc == 7 */
X      Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
X        /* Int_3_Loc == 7 */
X      Int_1_Loc += 1;
X    } /* while */
X      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
X    Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
X      /* Int_Glob == 5 */
X    Proc_1 (Ptr_Glob);
X    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
X                             /* loop body executed twice */
X    {
X      if (Enum_Loc == Func_1 (Ch_Index, 'C'))
X          /* then, not executed */
X        {
X        Proc_6 (Ident_1, &Enum_Loc);
X        strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
X        Int_2_Loc = Run_Index;
X        Int_Glob = Run_Index;
X        }
X    }
X      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
X    Int_2_Loc = Int_2_Loc * Int_1_Loc;
X    Int_1_Loc = Int_2_Loc / Int_3_Loc;
X    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
X      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
X    Proc_2 (&Int_1_Loc);
X      /* Int_1_Loc == 5 */
X
X  } /* loop "for Run_Index" */
X
X  /**************/
X  /* Stop timer */
X  /**************/
X  
X#ifdef TIMES
X  times (&time_info);
X  End_Time = (long) time_info.tms_utime;
X#endif
X#ifdef TIME
X  End_Time = time ( (long *) 0);
X#endif
X
X  printf ("Execution ends\n");
X  printf ("\n");
X  printf ("Final values of the variables used in the benchmark:\n");
X  printf ("\n");
X  printf ("Int_Glob:            %d\n", Int_Glob);
X  printf ("        should be:   %d\n", 5);
X  printf ("Bool_Glob:           %d\n", Bool_Glob);
X  printf ("        should be:   %d\n", 1);
X  printf ("Ch_1_Glob:           %c\n", Ch_1_Glob);
X  printf ("        should be:   %c\n", 'A');
X  printf ("Ch_2_Glob:           %c\n", Ch_2_Glob);
X  printf ("        should be:   %c\n", 'B');
X  printf ("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
X  printf ("        should be:   %d\n", 7);
X  printf ("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
X  printf ("        should be:   Number_Of_Runs + 10\n");
X  printf ("Ptr_Glob->\n");
X  printf ("  Ptr_Comp:          %d\n", (int) Ptr_Glob->Ptr_Comp);
X  printf ("        should be:   (implementation-dependent)\n");
X  printf ("  Discr:             %d\n", Ptr_Glob->Discr);
X  printf ("        should be:   %d\n", 0);
X  printf ("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
X  printf ("        should be:   %d\n", 2);
X  printf ("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
X  printf ("        should be:   %d\n", 17);
X  printf ("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
X  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
X  printf ("Next_Ptr_Glob->\n");
X  printf ("  Ptr_Comp:          %d\n", (int) Next_Ptr_Glob->Ptr_Comp);
X  printf ("        should be:   (implementation-dependent), same as above\n");
X  printf ("  Discr:             %d\n", Next_Ptr_Glob->Discr);
X  printf ("        should be:   %d\n", 0);
X  printf ("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
X  printf ("        should be:   %d\n", 1);
X  printf ("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
X  printf ("        should be:   %d\n", 18);
X  printf ("  Str_Comp:          %s\n",
X                                Next_Ptr_Glob->variant.var_1.Str_Comp);
X  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
X  printf ("Int_1_Loc:           %d\n", Int_1_Loc);
X  printf ("        should be:   %d\n", 5);
X  printf ("Int_2_Loc:           %d\n", Int_2_Loc);
X  printf ("        should be:   %d\n", 13);
X  printf ("Int_3_Loc:           %d\n", Int_3_Loc);
X  printf ("        should be:   %d\n", 7);
X  printf ("Enum_Loc:            %d\n", Enum_Loc);
X  printf ("        should be:   %d\n", 1);
X  printf ("Str_1_Loc:           %s\n", Str_1_Loc);
X  printf ("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
X  printf ("Str_2_Loc:           %s\n", Str_2_Loc);
X  printf ("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
X  printf ("\n");
X
X  User_Time = End_Time - Begin_Time;
X
X  if (User_Time < Too_Small_Time)
X  {
X    printf ("Measured time too small to obtain meaningful results\n");
X    printf ("Please increase number of runs\n");
X    printf ("\n");
X  }
X  else
X  {
X#ifdef TIME
X    Microseconds = (float) User_Time * Mic_secs_Per_Second 
X                        / (float) Number_Of_Runs;
X    Dhrystones_Per_Second = (float) Number_Of_Runs / (float) User_Time;
X#else
X    Microseconds = (float) User_Time * Mic_secs_Per_Second 
X                        / ((float) HZ * ((float) Number_Of_Runs));
X    Dhrystones_Per_Second = ((float) HZ * (float) Number_Of_Runs)
X                        / (float) User_Time;
X#endif
X    printf ("Microseconds for one run through Dhrystone: ");
X    printf ("%6.1f \n", Microseconds);
X    printf ("Dhrystones per Second:                      ");
X    printf ("%6.1f \n", Dhrystones_Per_Second);
X    printf ("\n");
X  }
X  
X}
X
X
XProc_1 (Ptr_Val_Par)
X/**********************/
X
XREG Rec_Pointer Ptr_Val_Par;
X    /* executed once */
X{
X  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;  
X                                        /* == Ptr_Glob_Next */
X  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
X  /* corresponds to "rename" in Ada, "with" in Pascal           */
X  
X  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob); 
X  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
X  Next_Record->variant.var_1.Int_Comp 
X        = Ptr_Val_Par->variant.var_1.Int_Comp;
X  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
X  Proc_3 (&Next_Record->Ptr_Comp);
X    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp 
X                        == Ptr_Glob->Ptr_Comp */
X  if (Next_Record->Discr == Ident_1)
X    /* then, executed */
X  {
X    Next_Record->variant.var_1.Int_Comp = 6;
X    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp, 
X           &Next_Record->variant.var_1.Enum_Comp);
X    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
X    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10, 
X           &Next_Record->variant.var_1.Int_Comp);
X  }
X  else /* not executed */
X    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
X} /* Proc_1 */
X
X
XProc_2 (Int_Par_Ref)
X/******************/
X    /* executed once */
X    /* *Int_Par_Ref == 1, becomes 4 */
X
XOne_Fifty   *Int_Par_Ref;
X{
X  One_Fifty  Int_Loc;  
X  Enumeration   Enum_Loc;
X
X  Int_Loc = *Int_Par_Ref + 10;
X  do /* executed once */
X    if (Ch_1_Glob == 'A')
X      /* then, executed */
X    {
X      Int_Loc -= 1;
X      *Int_Par_Ref = Int_Loc - Int_Glob;
X      Enum_Loc = Ident_1;
X    } /* if */
X  while (Enum_Loc != Ident_1); /* true */
X} /* Proc_2 */
X
X
XProc_3 (Ptr_Ref_Par)
X/**********************/
X    /* executed once */
X    /* Ptr_Ref_Par becomes Ptr_Glob */
X
XRec_Pointer *Ptr_Ref_Par;
X
X{
X  if (Ptr_Glob != Null)
X    /* then, executed */
X    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
X  else /* not executed */
X    Int_Glob = 100;
X  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
X} /* Proc_3 */
X
X
X
XProc_4 () /* without parameters */
X/*******/
X    /* executed once */
X{
X  Boolean Bool_Loc;
X
X  Bool_Loc = Ch_1_Glob == 'A';
X  Bool_Glob = Bool_Loc | Bool_Glob;
X  Ch_2_Glob = 'B';
X} /* Proc_4 */
X
X
XProc_5 () /* without parameters */
X/*******/
X    /* executed once */
X{
X  Ch_1_Glob = 'A';
X  Bool_Glob = false;
X} /* Proc_5 */
X
X
X        /* Procedure for the assignment of structures,          */
X        /* if the C compiler doesn't support this feature       */
X#ifdef  NOSTRUCTASSIGN
Xmemcpy (d, s, l)
Xregister char   *d;
Xregister char   *s;
Xregister int    l;
X{
X        while (l--) *d++ = *s++;
X}
X#endif
X
X
SHAR_EOF
fi
if test -f 'dhry_pack_2.c'
then
	echo shar: "will not over-write existing file 'dhry_pack_2.c'"
else
sed 's/^X//' << \SHAR_EOF > 'dhry_pack_2.c'
X/*
X ****************************************************************************
X *
X *                   "DHRYSTONE" Benchmark Program
X *                   -----------------------------
X *                                                                            
X *  Version:    C, Version 2.0
X *                                                                            
X *  File:       dhry_pack_2.c (part 3 of 3)
X *
X *  Date:       March 3, 1988
X *
X *  Author:     Reinhold P. Weicker
X *
X ****************************************************************************
X */
X
X#include "dhry_global.h"
X
X#ifndef REG
X#define REG
X        /* REG becomes defined as empty */
X        /* i.e. no register variables   */
X#endif
X
Xextern  int     Int_Glob;
Xextern  char    Ch_1_Glob;
X
X
XProc_6 (Enum_Val_Par, Enum_Ref_Par)
X/*********************************/
X    /* executed once */
X    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
X
XEnumeration  Enum_Val_Par;
XEnumeration *Enum_Ref_Par;
X{
X  *Enum_Ref_Par = Enum_Val_Par;
X  if (! Func_3 (Enum_Val_Par))
X    /* then, not executed */
X    *Enum_Ref_Par = Ident_4;
X  switch (Enum_Val_Par)
X  {
X    case Ident_1: 
X      *Enum_Ref_Par = Ident_1;
X      break;
X    case Ident_2: 
X      if (Int_Glob > 100)
X        /* then */
X      *Enum_Ref_Par = Ident_1;
X      else *Enum_Ref_Par = Ident_4;
X      break;
X    case Ident_3: /* executed */
X      *Enum_Ref_Par = Ident_2;
X      break;
X    case Ident_4: break;
X    case Ident_5: 
X      *Enum_Ref_Par = Ident_3;
X      break;
X  } /* switch */
X} /* Proc_6 */
X
X
XProc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
X/**********************************************/
X    /* executed three times                                      */ 
X    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
X    /*                  Int_Par_Ref becomes 7                    */
X    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
X    /*                  Int_Par_Ref becomes 17                   */
X    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
X    /*                  Int_Par_Ref becomes 18                   */
XOne_Fifty       Int_1_Par_Val;
XOne_Fifty       Int_2_Par_Val;
XOne_Fifty      *Int_Par_Ref;
X{
X  One_Fifty Int_Loc;
X
X  Int_Loc = Int_1_Par_Val + 2;
X  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
X} /* Proc_7 */
X
X
XProc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
X/*********************************************************************/
X    /* executed once      */
X    /* Int_Par_Val_1 == 3 */
X    /* Int_Par_Val_2 == 7 */
XArr_1_Dim       Arr_1_Par_Ref;
XArr_2_Dim       Arr_2_Par_Ref;
Xint             Int_1_Par_Val;
Xint             Int_2_Par_Val;
X{
X  REG One_Fifty Int_Index;
X  REG One_Fifty Int_Loc;
X
X  Int_Loc = Int_1_Par_Val + 5;
X  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
X  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
X  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
X  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
X    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
X  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
X  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
X  Int_Glob = 5;
X} /* Proc_8 */
X
X
XEnumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
X/*************************************************/
X    /* executed three times                                         */
X    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
X    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
X    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
X
XCapital_Letter   Ch_1_Par_Val;
XCapital_Letter   Ch_2_Par_Val;
X{
X  Capital_Letter        Ch_1_Loc;
X  Capital_Letter        Ch_2_Loc;
X
X  Ch_1_Loc = Ch_1_Par_Val;
X  Ch_2_Loc = Ch_1_Loc;
X  if (Ch_2_Loc != Ch_2_Par_Val)
X    /* then, executed */
X    return (Ident_1);
X  else  /* not executed */
X  {
X    Ch_1_Glob = Ch_1_Loc;
X    return (Ident_2);
X   }
X} /* Func_1 */
X
X
XBoolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
X/*************************************************/
X    /* executed once */
X    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
X    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
X
XStr_30  Str_1_Par_Ref;
XStr_30  Str_2_Par_Ref;
X{
X  REG One_Thirty        Int_Loc;
X      Capital_Letter    Ch_Loc;
X
X  Int_Loc = 2;
X  while (Int_Loc <= 2) /* loop body executed once */
X    if (Func_1 (Str_1_Par_Ref[Int_Loc],
X                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
X      /* then, executed */
X    {
X      Ch_Loc = 'A';
X      Int_Loc += 1;
X    } /* if, while */
X  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
X    /* then, not executed */
X    Int_Loc = 7;
X  if (Ch_Loc == 'R')
X    /* then, not executed */
X    return (true);
X  else /* executed */
X  {
X    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
X      /* then, not executed */
X    {
X      Int_Loc += 7;
X      Int_Glob = Int_Loc;
X      return (true);
X    }
X    else /* executed */
X      return (false);
X  } /* if Ch_Loc */
X} /* Func_2 */
X
X
XBoolean Func_3 (Enum_Par_Val)
X/***************************/
X    /* executed once        */
X    /* Enum_Par_Val == Ident_3 */
XEnumeration Enum_Par_Val;
X{
X  Enumeration Enum_Loc;
X
X  Enum_Loc = Enum_Par_Val;
X  if (Enum_Loc == Ident_3)
X    /* then, executed */
X    return (true);
X} /* Func_3 */
X
SHAR_EOF
fi
exit 0
#	End of shell archive
